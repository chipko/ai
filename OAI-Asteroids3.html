<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>3D Solar System Simulation with Asteroids</title>
    <!-- p5.js for drawing and vector math -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.js"></script>
    <style>
      body {
        margin: 0;
        padding: 0;
        background: #000;
        color: #fff;
        font-family: sans-serif;
      }
      /* UI container */
      #ui {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 10;
        background: rgba(0,0,0,0.6);
        padding: 10px;
        border-radius: 5px;
      }
      #ui label { font-size: 14px; }
      #ui input, #ui span { vertical-align: middle; }
    </style>
  </head>
  <body>
    <div id="ui">
      <label>
        <input type="checkbox" id="fadeCheckbox"> Fade Trails
      </label>
      <br>
      <label>
        <input type="checkbox" id="collisionCheckbox" checked> Enable Collisions
      </label>
      <br>
      <label>
        <input type="checkbox" id="fancyTrailsCheckbox"> Fancy Trails
      </label>
      <br>
      <label>
        Collision Multiplier: 
        <input type="range" id="collisionSlider" min="1" max="3" step="0.1" value="1">
      </label>
      <span id="collisionValue">1</span>
      <br>
      <p>
        <strong>Controls:</strong><br>
        Left‑drag: Create asteroid<br>
        Right‑drag: Rotate view<br>
        Shift+Right‑drag or Middle‑drag: Pan view
      </p>
    </div>
    <script>
      // Simulation objects
      let sun;
      let planets = [];
      let asteroids = [];
      const G = 1; // Gravitational constant (arbitrary units)

      // UI elements
      let fadeCheckbox, collisionCheckbox, fancyTrailsCheckbox, collisionSlider, collisionValueDisplay;

      // For asteroid creation (left-drag)
      let leftDragging = false;
      let dragStart = null;

      // View controls: rotation and panning in 3D
      let viewRotationX = 0, viewRotationY = 0;
      let viewTranslation;
      let rotating = false, paning = false;
      let rotationStart = null, initialRotationX, initialRotationY;
      let panStart = null, initialPan;

      function setup() {
        // Use WEBGL with an orthographic projection so that our simulation (in the x-y plane) remains linear.
        createCanvas(windowWidth, windowHeight, WEBGL);
        ortho(-width/2, width/2, height/2, -height/2, -5000, 5000);
        viewTranslation = createVector(0, 0, 0);

        // Setup UI controls
        fadeCheckbox = select('#fadeCheckbox');
        collisionCheckbox = select('#collisionCheckbox');
        fancyTrailsCheckbox = select('#fancyTrailsCheckbox');
        collisionSlider = select('#collisionSlider');
        collisionValueDisplay = select('#collisionValue');

        // The Sun is at the origin (which is the center of our simulation)
        sun = {
          pos: createVector(0, 0, 0),
          mass: 10000,
          radius: 30,
          color: 'yellow'
        };

        // Define eight planets orbiting in the x-y plane
        planets = [
          { name: "Mercury", distance: 60,  mass: 10,  angle: random(TWO_PI), angularSpeed: 0.03, radius: 4,  color: 'gray' },
          { name: "Venus",   distance: 90,  mass: 20,  angle: random(TWO_PI), angularSpeed: 0.025, radius: 6,  color: 'orange' },
          { name: "Earth",   distance: 120, mass: 30,  angle: random(TWO_PI), angularSpeed: 0.02, radius: 6,  color: 'blue' },
          { name: "Mars",    distance: 150, mass: 25,  angle: random(TWO_PI), angularSpeed: 0.018, radius: 5,  color: 'red' },
          { name: "Jupiter", distance: 200, mass: 100, angle: random(TWO_PI), angularSpeed: 0.015, radius: 12, color: 'orange' },
          { name: "Saturn",  distance: 250, mass: 80,  angle: random(TWO_PI), angularSpeed: 0.012, radius: 10, color: 'goldenrod' },
          { name: "Uranus",  distance: 300, mass: 60,  angle: random(TWO_PI), angularSpeed: 0.01, radius: 8,  color: 'lightblue' },
          { name: "Neptune", distance: 350, mass: 60,  angle: random(TWO_PI), angularSpeed: 0.009, radius: 8,  color: 'blue' }
        ];
      }

      function draw() {
        // Update collision multiplier display
        collisionValueDisplay.html(collisionSlider.value());

        // If "Fade Trails" is enabled, overlay a translucent rectangle so previous frames gradually fade.
        if (fadeCheckbox.checked()) {
          noStroke();
          fill(0, 30);
          rect(-width/2, -height/2, width, height);
        } else {
          background(0);
        }

        // Apply view transformations (translation and 3D rotation)
        push();
        translate(viewTranslation.x, viewTranslation.y, viewTranslation.z);
        rotateX(viewRotationX);
        rotateY(viewRotationY);

        // Draw the simulation objects in the x-y plane (z=0)
        // Draw planet orbits
        stroke(100);
        noFill();
        for (let planet of planets) {
          ellipse(sun.pos.x, sun.pos.y, planet.distance * 2, planet.distance * 2);
        }

        // Draw the Sun
        noStroke();
        fill(sun.color);
        ellipse(sun.pos.x, sun.pos.y, sun.radius * 2);

        // Update and draw planets (each follows a circular orbit)
        for (let planet of planets) {
          planet.angle += planet.angularSpeed;
          planet.pos = createVector(
            sun.pos.x + planet.distance * cos(planet.angle),
            sun.pos.y + planet.distance * sin(planet.angle),
            0
          );
          fill(planet.color);
          ellipse(planet.pos.x, planet.pos.y, planet.radius * 2);
        }

        // If left-dragging for asteroid creation, show the intended drag vector (in simulation coordinates)
        if (leftDragging && dragStart) {
          let currentSim = screenToSim(mouseX, mouseY);
          stroke(255);
          line(dragStart.x, dragStart.y, currentSim.x, currentSim.y);
          push();
          let arrowVec = p5.Vector.sub(currentSim, dragStart);
          translate(currentSim.x, currentSim.y);
          rotate(arrowVec.heading());
          let arrowSize = 7;
          line(0, 0, -arrowSize, -arrowSize/2);
          line(0, 0, -arrowSize, arrowSize/2);
          pop();
        }

        // Update and draw asteroids
        for (let i = asteroids.length - 1; i >= 0; i--) {
          let a = asteroids[i];
          // Calculate gravitational acceleration from the Sun and each planet
          let acceleration = createVector(0, 0, 0);
          function applyGravity(bodyPos, bodyMass) {
            let force = p5.Vector.sub(bodyPos, a.pos);
            let distance = force.mag();
            distance = max(distance, 5); // avoid singularity
            force.normalize();
            let strength = (G * bodyMass) / (distance * distance);
            force.mult(strength);
            acceleration.add(force);
          }
          applyGravity(sun.pos, sun.mass);
          for (let planet of planets) {
            applyGravity(planet.pos, planet.mass);
          }
          a.vel.add(acceleration);
          a.pos.add(a.vel);
          a.path.push(a.pos.copy());

          // If collisions are enabled, remove the asteroid when it gets too close
          if (collisionCheckbox.checked()) {
            let collisionMultiplier = parseFloat(collisionSlider.value());
            if (p5.Vector.dist(a.pos, sun.pos) < sun.radius * collisionMultiplier) {
              asteroids.splice(i, 1);
              continue;
            }
            for (let planet of planets) {
              if (p5.Vector.dist(a.pos, planet.pos) < planet.radius * collisionMultiplier) {
                asteroids.splice(i, 1);
                break;
              }
            }
          }

          // Draw the asteroid's trail
          if (fancyTrailsCheckbox.checked()) {
            // Fancy trails: draw line segments with gradient alpha along the path.
            for (let j = 0; j < a.path.length - 1; j++) {
              let alphaVal = map(j, 0, a.path.length - 1, 50, 255);
              stroke(red(a.trailColor), green(a.trailColor), blue(a.trailColor), alphaVal);
              line(a.path[j].x, a.path[j].y, a.path[j+1].x, a.path[j+1].y);
            }
          } else {
            noFill();
            stroke(a.trailColor);
            beginShape();
            for (let pt of a.path) {
              vertex(pt.x, pt.y);
            }
            endShape();
          }

          // Draw the asteroid itself
          fill(a.trailColor);
          noStroke();
          ellipse(a.pos.x, a.pos.y, 8);
        }
        pop(); // End view transformation
      }

      // Helper: rotate a vector around the X axis by a given angle
      function rotateVectorX(v, angle) {
        let cosA = cos(angle);
        let sinA = sin(angle);
        let y = v.y * cosA - v.z * sinA;
        let z = v.y * sinA + v.z * cosA;
        return createVector(v.x, y, z);
      }
      // Helper: rotate a vector around the Y axis by a given angle
      function rotateVectorY(v, angle) {
        let cosA = cos(angle);
        let sinA = sin(angle);
        let x = v.x * cosA + v.z * sinA;
        let z = -v.x * sinA + v.z * cosA;
        return createVector(x, v.y, z);
      }

      // Convert screen (mouse) coordinates to simulation coordinates in the x-y plane (z = 0)
      // This undoes the view transformation.
      function screenToSim(x, y) {
        // Convert screen coordinates (with center at width/2,height/2) to a vector
        let v = createVector(x - width/2, y - height/2, 0);
        // Invert translation
        v.sub(viewTranslation);
        // Invert rotation: first around X, then Y (order must match the drawing transforms)
        v = rotateVectorX(v, -viewRotationX);
        v = rotateVectorY(v, -viewRotationY);
        return v;
      }

      // Mouse event handlers
      function mousePressed() {
        if (mouseButton === LEFT) {
          // Start left-drag to set asteroid velocity (in simulation coordinates)
          leftDragging = true;
          dragStart = screenToSim(mouseX, mouseY);
        } else if (mouseButton === RIGHT) {
          // If SHIFT is held or middle-button (if available) use panning; otherwise rotate view.
          if (keyIsDown(SHIFT)) {
            paning = true;
            panStart = createVector(mouseX, mouseY);
            initialPan = viewTranslation.copy();
          } else {
            rotating = true;
            rotationStart = createVector(mouseX, mouseY);
            initialRotationX = viewRotationX;
            initialRotationY = viewRotationY;
          }
        } else if (mouseButton === CENTER) {
          paning = true;
          panStart = createVector(mouseX, mouseY);
          initialPan = viewTranslation.copy();
        }
      }

      function mouseDragged() {
        if (rotating) {
          let dx = mouseX - rotationStart.x;
          let dy = mouseY - rotationStart.y;
          viewRotationY = initialRotationY + dx * 0.005;
          viewRotationX = initialRotationX + dy * 0.005;
        } else if (paning) {
          let dx = mouseX - panStart.x;
          let dy = mouseY - panStart.y;
          viewTranslation = initialPan.copy().add(createVector(dx, dy, 0));
        }
      }

      function mouseReleased() {
        if (mouseButton === LEFT && leftDragging) {
          leftDragging = false;
          let dragEnd = screenToSim(mouseX, mouseY);
          // The initial velocity is determined by the drag vector (scaled appropriately)
          let initialVelocity = p5.Vector.sub(dragEnd, dragStart).mult(0.05);
          // Assign a random trail color to each asteroid.
          let trailColor = color(random(100, 255), random(100, 255), random(100, 255));
          asteroids.push({
            pos: dragStart.copy(),
            vel: initialVelocity,
            path: [dragStart.copy()],
            trailColor: trailColor
          });
        } else if (mouseButton === RIGHT) {
          rotating = false;
          paning = false;
        } else if (mouseButton === CENTER) {
          paning = false;
        }
      }

      function windowResized() {
        resizeCanvas(windowWidth, windowHeight);
        ortho(-width/2, width/2, height/2, -height/2, -5000, 5000);
      }
    </script>
  </body>
</html>
